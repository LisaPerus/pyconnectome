# System import
import os
import glob
import re

# Third-Party imports
import nibabel

# Package import
from pyconnectome.wrapper import FSLWrapper
from pyconnectome import DEFAULT_FSL_PATH


"""
DTI-Tk Preprocessing
"""


def dtitk_import_tensors(basename, output_dir, tool="FSL",
                         outliers=True, spd=True, origin=True,
                         isotropic=False):
    """ Runs dti-tk preprocessing steps on a tensor file:
    1) Convert file to dti-tk nifti tensor format.
    2) Put image file origin to [0, 0, 0].
    3) Resample image to isotropic voxels.

    For more information, please refer to :
    http://dti-tk.sourceforge.net/pmwiki/pmwiki.php?n=Documentation.BeforeReg

    Parameters
    ----------
    basename: str
        basename for FSL-generated DTI eigensystem files (e.g: dtifit).
    output_dir: str
        path to output directory.
    tool: str
        tool used to generate the DTI eigensystem files.
    outliers: bool
        Removes outlier voxels.
    spd: bool
        Checks if diffusion tensor has a symmetric and
        positive-definite matrix. Creates a new symmetric and
        positive-definite matrix.
    origin: bool
        Puts volume file origin to [0, 0, 0].
    isotropic: bool
        Puts voxels to isotropic dimensions.

    Returns
    -------
    tensor_dtitk: str
        path to the modified tensor image that can be used for dtitk
        processing.
    """
    if tool == "FSL":
        # Convert freesurfer tensor image data to dti-tk nifti tensor
        tensor_dtitk = convert_fsl_to_nifti_tensor_format(
            basename=basename,
            out_dir=output_dir)

        # Convert the diffusivity unit to DTITK compatible one
        multiplier = 1000
        cmd = "TVtool -in {0} -scale {1} -out {0}".format(
            tensor_dtitk, multiplier)
        os.system(cmd)

        # Assume that the brain extraction has been done
        if outliers:
            # Remove outliers quantified with tensor norm
            tensor_norm, tensor_non_outliers = remove_outliers(
                tensor_dtitk=tensor_dtitk)

        if spd:
            # Convert to SPD
            check_spd(tensor_dtitk=tensor_dtitk)

        if origin:
            # Put origin to [0, 0, 0]
            TVAdjustVoxelspace(
                img=tensor_dtitk,
                out_file=tensor_dtitk,
                origin=[0, 0, 0])

        if isotropic:
            # Resample to isotropic voxels
            tensor_dtitk_img = nibabel.load(tensor_dtitk)
            vsize_init = tensor_dtitk_img.header.get_zooms()
            size_init = tensor_dtitk_img.shape
            vsize = [1, 1, 1]
            size = []
            for i in range(len(size_init[:3])):
                size.append(size_init[i]*vsize_init[i]/vsize[i])
            TVResample(
                img_file=tensor_dtitk,
                vsize=vsize,
                size=size,
                out_file=tensor_dtitk)

    return tensor_dtitk


def convert_fsl_to_nifti_tensor_format(basename, out_dir, tool="FSL"):
    """ Wraps DTI-TK commands and Convert FSL-formatted tensor outputs
        (*_V{1,2,3}.nii.gz and *_L{1,2,3}.nii.gz) to NIfTI tensor format
        and preprocess appropriately

    Parameters
    ----------
    basename: str
        basename for the DTI eigensystem files (e.g: dtifit).
    out_dir: str
        output directory path for files generated by nifti format conversion
        and diffusion units scaling. Files generated by the options outliers,
        spd and origin will be created in the volume input file directory.
    tool: str
        tool used to generate the the DTI eigensystem files

    Returns
    -------
    tensor_dtitk: str
        path to the created .nii file usable by dti-tk.
    """
    if tool == "FSL":
        if not os.path.isdir(out_dir):
            raise ValueError("convert_fsl_to_nifti_tensor_format: invalid"
                             " output directory {0}...".format(out_dir))
        tensor_dtitk = "{0}_dtitk.nii.gz".format(
            os.path.join(out_dir, os.path.basename(basename)))

        # Convert from FSL eigensystem (_V{1,2,3} and _L{1,2,3}) to
        # NIfTI tensor format
        cmd = "TVFromEigenSystem -basename {0} -out {1} -type FSL".format(
              basename, tensor_dtitk)
        os.system(cmd)

    else:
        raise NotImplementedError(
            "Interoperability between DTI-TK and {0} has not been implemented"
            " yet.".format(tool))

    return tensor_dtitk


def remove_outliers(tensor_dtitk, norm_outlier_threshold=100):
    """ Wraps DTI-TK commands to identify outliers voxels and remove them by
        masking.

    Parameters
    ----------
    tensor_dtitk: str
        path to dti volume in NIFTI tensor format.
    norm_outlier_threshold: float
        threshold for outliers.

    Returns
    -------
    tensor_norm: str
        path to the norm nii file of tensor_dtitk.
    tensor_non_outliers: str
        path to the outliers nii file of tensor_dtitk.
    """
    print("Removing outliers for volume {0}...".format(tensor_dtitk))
    tensor_norm = re.sub(".nii.gz", "_norm.nii.gz", tensor_dtitk)
    cmd = "TVtool -in {0} -norm -out {1}".format(tensor_dtitk, tensor_norm)
    os.system(cmd)

    # Print statistics
    cmd = "SVtool -in {0} -stats".format(tensor_norm)
    os.system(cmd)

    # Binary thresholding to identify outlier voxels
    tensor_non_outliers = re.sub(".nii.gz", "_non_outliers.nii.gz",
                                 tensor_dtitk)
    cmd = ("BinaryThresholdImageFilter {0} {1} 0 {2} 1 0".format(
        tensor_norm, tensor_non_outliers, str(norm_outlier_threshold)))
    os.system(cmd)

    # Remove outlier voxels by masking
    cmd = "TVtool -in {0} -mask {1} -out {0}".format(tensor_dtitk,
                                                     tensor_non_outliers)
    os.system(cmd)
    print("Outliers removed...")

    return tensor_norm, tensor_non_outliers


def check_spd(tensor_dtitk):
    """ Wraps DTI-TK command TVtool to check if diffusion tensor has a
        symmetric and positive-definite matrix, or SPD.

    Parameters
    ----------
    tensor_dtitk: str
        path to dtitk volume.
    """
    cmd = "TVtool -in {0} -spd -out {0}".format(tensor_dtitk)
    os.system(cmd)


def TVAdjustVoxelspace(img, out_file, origin):
    """ Wraps DTI-TK command TVAdjustVoxelspace to put origin to [0, 0, 0].

    Parameters
    ----------
    img: str
        path to .nii file.
    out_file: str
        path to output file.
    origin: list
        list containing origin position e.g [0, 0, 0]
    """
    cmd = "TVAdjustVoxelspace -in {0} -origin {2} {3} {4} -out {1}".format(
          img, out_file, origin[0], origin[1], origin[2])
    os.system(cmd)


def TVResample(img_file, vsize, size, out_file):
    """ Wraps DTI-TK command TVResample to resample an image given a voxel
        size.

    Parameters
    ----------
    tensor_file: str
        path to a .nii file.
    vsize: array N(1,3)
        array of voxel dimensions.
    size: array N(1,3)
        output image size.
    out_file: str
        path to output file.
    """
    cmd = ("TVResample -in {0} -vsize {1} {2} {3} -size {4} {5} {6} "
           " -out {7}".format(img_file, vsize[0], vsize[1],
                              vsize[2], size[0], size[1], size[2], out_file))
    os.system(cmd)


"""
DTI-Tk template creation
"""


def dti_template_bootstrap(template, subjects_file):
    """ Wraps DTI-TK script dti_template_bootstrap which bootstrap an initial
        template estimate from a set of DTI volumes.

    Parameters
    ----------
    template: str
        the path to the template file.
    subjects_file: str
        the path to the file listing all subjects dti files (already
        preprocessed for dti-tk).
    Returns
    -------
    output_template: str
        path to the created template.
    """
    cmd = ["dti_template_bootstrap", template, subjects_file]
    cmd = " ".join(cmd)
    os.system(cmd)
    output_dir = os.path.dirname(template)
    output_template = os.path.join(output_dir, "mean_initial.nii.gz")
    return output_template


def bootstrap_template_from_dti(subjects, out_template, typep="ORIGINAL",
                                interp="LEI"):
    """Wraps DTI-TK TVMean command and create a boostrap template from dti
       files.
    Parameters
    ----------
    subjects: str
        path to a file listing the subjects dti volumes preprocessed for
        dti-tk.
    out_template: str
        path to the output template.
    typep: str
        can be ORIGINAL or DYADIC. Default is ORIGINAL.
    interp: str
        type of interpolation. Can be euclidian (EI) or log-euclidian
        interpolation (LEI). Default is LEI.

    Returns
    -------
    out_template: str
        path to the output template.
    """
    cmd = ["TVMean", "-in", subjects, "-out", out_template, "-type", typep,
           "-interp", interp]
    cmd = " ".join(cmd)
    os.system(cmd)
    return out_template


def dtitk_create_mean_template(subject_list, out_path,
                               template_dim=[128, 128, 64]):
    """ Uses DTI-TK command TVMean and create a template from a list of
        DTI NIFTI files and resample it with voxel dimensions being powers of
        2.

    Parameters
    ----------
    subject_list: str
        the path to the list of subjects' DTI nii files.
    out_path: str
        the path to the created template.
    template_dim: array
        new template dimensions, must be power of 2. If created template
        dimensions are power of 2, there is no need to resample.
    Returns
    -------
    template: str
        path to the created template.
    """
    # Create the boostrap template
    template = os.path.join(out_path, "mean_initial.nii.gz")
    template = bootstrap_template_from_dti(subject_list, template)

    # Resample the template into a voxel space with the voxel dimensions being
    # powers of 2 (DTI-TK mandatory step).
    # The volumes that will be registered on the template do NOT need to have
    # powers of 2 volume dimensions.
    template_img = nibabel.load(template)
    template_img_shape = template_img.get_data().shape[:3]
    template_img_voxel_sizes = template_img.header.get_zooms()[:3]
    new_voxel_dim = [1, 1, 1]
    for i, dim in enumerate(template_dim):
        new_voxel_dim[i] = ((template_dim[i] / template_img_shape[i]) *
                            template_img_voxel_sizes[i])
    new_voxel_dim = "{0} {1} {2}".format(
        new_voxel_dim[0], new_voxel_dim[1], new_voxel_dim[2])
    template_dim = "{0} {1} {2}".format(
        template_dim[0], template_dim[1], template_dim[2])
    cmd = ["TVResample", "-in", template, "-align", "center", "-size",
           template_dim, "-vsize", new_voxel_dim]
    cmd = " ".join(cmd)
    os.system(cmd)

    return template


def rigid_alignment_population(template, subjects, output_dir, SMOption,
                               no_of_iterations, optimized=False):
    """ Wraps DTI-TK script dti_rigid_population and rigidly align a set of
        DTI volume (subjects) to a template. The optimized templates will be
        saved as mean_rigid{1,2,..,no_of_iterations}.nii.gz. The aligned
        volumes are computed and their filenames are stored in "subjs_aff.txt".
    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the text file list of DTI-TK nii files.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    no_of_iterations: int
        the number of iterations to optimize the template over the whole
        process.
    optimized: bool (optional, default False)
        if the input template is already optimized.

    Returns
    -------
    output: str
        path to the mean rigid template of tensor files.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)

    if optimized:
        cmd = "dti_rigid_population {0} {1} {2}".format(template, subjects,
                                                        SMOption)
    else:
        cmd = "dti_rigid_population {0} {1} {2} {3}".format(template, subjects,
                                                            SMOption,
                                                            no_of_iterations)
    os.system(cmd)
    output = os.path.join(output_dir,
                          "mean_rigid{0}.nii.gz".format(no_of_iterations))
    return output


def affine_alignment_population(template, subjects_dti_file, output_dir,
                                SMOption, no_of_iterations):
    """ Wraps DTI-TK script dti_affine_population and affinely align a set of
    DTI volume (subjects) to a template. The optimized templates will be
    saved as mean_affine{1,2,..,no_of_iterations}.nii.gz. The aligned
    volumes are computed and their filenames are stored in "subjs_aff.txt".
    Parameters
    ----------
    template: str
        the path to the template.
    subjects_dti_file: str
        the path to the text file list of DTI-TK nii files.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    no_of_iterations: int
        the number of iterations to optimize the template over the whole
        process.
    Returns
    -------
    affine_template: str
        the path to the generated affine template.
    subjects_dti_aff_file: str
        the path to the list of subjects dti volumes registered to the affine
        template.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = "dti_affine_population {0} {1} {2} {3}".format(
        template, subjects_dti_file, SMOption, no_of_iterations)
    os.system(cmd)
    output_dir = os.path.dirname(subjects_dti_file)
    affine_template = os.path.join(
        output_dir, "mean_affine{0}.nii.gz".format(no_of_iterations))
    subjects_dti_aff_file = subjects_dti_file.replace(".txt", "_aff.txt")
    return affine_template, subjects_dti_aff_file


def deformable_alignment_population(affine_template, subjects_affine,
                                    output_dir, ftol):
    """ Wraps DTI-TK script dti_diffeomorphic_population which improves
        alignment by removing size or shape differences between local
        structures.
    Parameters
    ----------
    affine_template: str
        the path to the template generated after affine alignment.
    subjects_affine: str
        the path to the subject list generated after affine alignment.
    output_dir: str
        the path to the output directory.
    ftol: float
        the minimum amount of change in the cost function.
    Returns
    -------
    deformable_template: str
        the path to the diffeormorphic registration template.
    mask: str
        the path to a binary image that has 0 for background voxels and 1 for
        brain tissue voxels.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)

    # Generate binary mask of brain tissue
    # > Compute the trace map of the template image
    trace_affine_template = re.sub(".nii.gz", "_tr.nii.gz", affine_template)
    cmd = "TVtool -in {0} -tr -out {1}".format(affine_template,
                                               trace_affine_template)
    os.system(cmd)
    # > Binary threshold the trace map to generate the mask image.
    mask = os.path.join(os.path.dirname(affine_template), "mask.nii.gz")
    cmd = ("BinaryThresholdImageFilter {0} {1} 0.01 100 1 0"
           .format(trace_affine_template, mask))
    os.system(cmd)

    # Spatial normalization
    cmd = ("dti_diffeomorphic_population {0} {1} {2} {3}".format(
            affine_template, subjects_affine, mask, ftol))
    os.system(cmd)
    deformable_template = os.path.join(
        output_dir, "mean_diffeomorphic_initial6.nii.gz")
    return deformable_template, mask


"""
DTI-Tk Registration
"""


def dti_rigid_reg(template, subject, output_dir, SMoption="EDS",
                  sep=[4.0, 4.0, 4.0], ftol=0.01, useInTrans=False):
    """ Wraps DTI-TK script dti_rigid_reg and rigidly align a subject
    DTI volume to a template.
    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the subject DWI volume.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    sep: float array
        the distance between the sample points in the volume for the evaluation
        of image similarity (mm).
    ftol: float
        the minimum amount of change in the cost function as a fraction of the
        previous value at the previous iteration for the registration
        optimization to stop.
    useInTrans: bool
        the optional input to specify whether to initialize with some
        previously determined transformation.

    Returns
    -------
    registered_subject: str
        path to the registered subject.
    transformation: str
        path to the transformation file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["dti_rigid_reg", template, subject, SMoption, str(sep[0]),
           str(sep[1]), str(sep[2]), str(ftol)]
    if useInTrans:
        cmd.append("1")
    cmd = " ".join(cmd)
    os.system(cmd)
    basename = subject.replace(".nii.gz", "")
    registered_subject = "{0}_aff.nii.gz".format(basename)
    transformation = "{0}.aff".format(basename)
    return registered_subject, transformation


def dti_affine_reg(template, subject, output_dir, SMoption="EDS",
                   sep=[4.0, 4.0, 4.0], ftol=0.01, useInTrans=False):
    """ Wraps DTI-TK script dti_affine_reg and affinely align a subject
    DTI volume to a template.
    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the subject DWI volume.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    sep: float array
        the distance between the sample points in the volume for the evaluation
        of image similarity (mm).
    ftol: float
        the minimum amount of change in the cost function as a fraction of the
        previous value at the previous iteration for the registration
        optimization to stop.
    useInTrans: bool
        the optional input to specify whether to initialize with some
        previously determined transformation.

    Returns
    -------
    registered_subject: str
        path to the registered subject.
    transformation: str
        path to the transformation file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["dti_affine_reg", template, subject, SMoption, str(sep[0]),
           str(sep[1]), str(sep[2]), str(ftol)]
    if useInTrans:
        cmd.append("1")
    cmd = " ".join(cmd)
    os.system(cmd)
    basename = subject.replace(".nii.gz", "")
    registered_subject = "{0}_aff.nii.gz".format(basename)
    transformation = "{0}.aff".format(basename)
    return registered_subject, transformation


def dti_diffeomorphic_reg(template, subject, mask, output_dir, no_of_iter=6,
                          ftol=0.002):
    """ Wraps DTI-TK script dti_diffeomorphic_reg and align a DTI volume
    to a template.
    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the DTI volume.
    mask: str
        the path to a binary image that has 0 for background voxels and 1 for
        brain tissue voxels.
    output_dir: str
        the path to the output directory.
    no_of_iter: int
        number of iterations.
    ftol: float
        the minimum amount of change in the cost function.

    Returns
    -------
    registered_subject: str
        path to the registered subject.
    transformation: str
        path to the transformation file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["dti_diffeomorphic_reg", template, subject, mask, "1",
           str(no_of_iter), str(ftol)]
    cmd = " ".join(cmd)
    os.system(cmd)
    registered_subject = subject.replace(".nii.gz", "_aff_diffeo.nii.gz")
    transformation = subject.replace(".nii.gz", "_aff_diffeo.df.nii.gz")
    return registered_subject, transformation


def dti_warp_to_template(subject, template, voxel_dim):
    """ Wraps DTI-TK script dti_warp_to_template which combines the
    affine transformation and diffeomorphic displacement field into
    one single displacement field and brings the subject's original data
    from raw space to the space of the template using a single
    interpolation.
    Parameters
    ----------
    subject: str
        the path to the subject tensor file.
    template: str
        the path to the combined displacement field (affine+deformable
        alignment) file.
    voxel_dim: array (dim 3)
        the array of voxel dimensions.

    Returns
    -------
    registered_subject: str
        path to the registered subject.
    combined_transformation: str
        path to the transformation combined file.
    """
    img_dim = "{0} {1} {2}".format(voxel_dim[0], voxel_dim[1], voxel_dim[2])
    cmd = "dti_warp_to_template {0} {1} {2}".format(subject, template, img_dim)
    os.system(cmd)
    registered_subject = subject.replace(".nii.gz", "_diffeo.nii.gz")
    combined_transformation = subject.replace(".nii.gz", "_combined.df.nii.gz")
    return registered_subject, combined_transformation


"""
DTI-Tk FA skeleton creation
"""


def generate_FA_map(dti_file, output_fa):
    """Use DTI-TK TVtool command to generate the FA map of a dti file.
    Parameters
    ----------
    dti_file: str
        path to the dti volume file.
    output_fa: str
        path to the output fa file.
    Returns
    -------
    output_fa_file: str
        path to the output fa file.
    """

    # Generate FA maps
    cmd = ["TVtool", "-in", dti_file, "-fa"]
    cmd = " ".join(cmd)
    os.system(cmd)
    fa_file = dti_file.replace(".nii.gz", "_fa.nii.gz")
    output_fa_file = os.path.join(os.path.dirname(fa_file), output_fa)

    # Rename the FA map to be consistent with the TBSS pipeline
    cmd = ["mv", fa_file, output_fa_file]
    cmd = " ".join(cmd)
    os.system(cmd)
    return output_fa_file


def skeletonize(input_file, output_file, skel_threshold=None,
                distance_map=None, search_rule_mask=None, data_4D=None,
                projected_4Ddata=None, alternative_4Ddata=None,
                alternative_skeleton=None, fsl_sh=DEFAULT_FSL_PATH):
    """Wraps tbss_skeleton commands and skeletonize FA image.

    Parameters
    ----------
    input_file: str
        path to the input file to skeletonize.
    output_file: str
        path to the output skeleton file.
    skel_threshold: str
        Skeleton threshold. Optional.
    distance_map: str
        Distance map.
    search_rule_mask: str
        search rule mask. Use FSL LowerCingulum_1mm.nii.gz file.
    data_4D: str
        data_4D.
    projected_4Ddata: str
        projected 4D data.
    alternative_4Ddata: str
        alternative 4D data.
    alternative_skeleton: str
        alternative skeleton.
    fsl_sh: str
        path to fsl setup sh file.
    Returns
    -------
    skeleton_file: str
        path to the generated skeleton file.
    """
    cmd = ["tbss_skeleton", "-i", input_file]

    if (skel_threshold is not None or distance_map is not None or
        search_rule_mask is not None or data_4D is not None or
            projected_4Ddata is not None):
        cmd.append("-p")
    if skel_threshold is not None:
        cmd.append(skel_threshold)
    if distance_map is not None:
        cmd.append(distance_map)
    if search_rule_mask is not None:
        cmd.append(search_rule_mask)
    if data_4D is not None:
        cmd.append(data_4D)
    if projected_4Ddata is not None:
        cmd.append(projected_4Ddata)
    if alternative_4Ddata is not None:
        cmd.append("-a")
        cmd.append(alternative_4Ddata)
    if alternative_skeleton is not None:
        cmd.append("-s")
        cmd.append(alternative_skeleton)
    cmd.append("-o")
    cmd.append(output_file)
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()

    return output_file


def fslmerge(images, concatenated_output, time=True, x=False, y=False, z=False,
             auto_choose=False, tr=False, fsl_sh=DEFAULT_FSL_PATH):
    """Wraps fslmerge commands and concatenate different nifti files.

    Parameters
    ----------
    images: list
        list of the images to concatenate.
    concatenated_output: str
        path to output concatenated volume.
    time: bool
        concatenate images in time.
    x: bool
        concatenate images in the x direction.
    y: bool
        concatenate images in the y direction.
    z: bool
        concatenate images in the z direction.
    auto_choose: bool
        single slices -> volume, volumes -> 4D (time series).
    tr: bool
        concatenate images in time and set the output image tr to the final
        option value.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    concatenated_output: str
        path to the concatenated images file.
    """
    cmd = ["fslmerge"]
    if time:
        cmd.append("-t")
    elif x:
        cmd.append("-x")
    elif y:
        cmd[1].append("-y")
    elif z:
        cmd[1].append("-z")
    elif auto_choose:
        cmd[1].append("-a")
    elif tr:
        cmd[1].append("-tr")
    else:
        raise ValueError(
            "Please set at least one of fslmerge option to True...")
    cmd.append(concatenated_output)
    for img in images:
        cmd.append(img)
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()

    return concatenated_output


def get_fa_stack_mask(fa_4D, output, fsl_sh=DEFAULT_FSL_PATH):
    """Wraps fslmaths command and create a combined binary mask volume from a
       FA 4D data of multiple subjects.
    Parameters
    ----------
    fa_4D: str
        path to the 4D FA data.
    output: str
        path to the combined binary mask volume.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    output: str
        path to the combined binary mask volume.
    """
    cmd = ["fslmaths", fa_4D, "-max", "0", "-Tmin", "-bin", output, "-odt",
           "char"]
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()
    return output


"""
TBSS
"""


def tbss_pipeline(tbss_dir, find_best_target=True, use_fmrib58_fa_1mm=False,
                  target_img=None, skel_threshold=0.2,
                  fsl_sh=DEFAULT_FSL_PATH):
    """Wraps tbss commands to execute tbss pipeline and generate FA skeleton.
       Steps:
        1) Preproc
        2) Register FA images to standard space.
        3) Applies the nonlinear transforms found in the previous stage to all
           subjects to bring them into standard space.
        4) Thresholds the mean FA skeleton image

    Parameters
    ----------
    tbss_dir: str
        path to tbss output directory.
    find_best_target: bool
        target image used for registration to standard space is the
        "most typical" subject in the study.
    use_fmrib58_fa_1mm: bool
        target image used for registration to standard space is the FMRIB58_FA
        standard-space image given by FSL.
    target_img: str
        target image that will be used for registration to standard space if
        find_best_target and use_fmrib58_fa_1mm parameters are set to False.
    skel_threshold: float
        threshold for the mean FA skeleton image thresholding.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    fa_dir: str
        path to the subjects corrected FA files.
    orig_dir: str
        path to the copied subjects original FA files.
    """

    os.chdir(tbss_dir)
    print("TBSS preprocessing...")
    fa_dir, orig_dir = tbss_1_preproc(
        output_dir=tbss_dir,
        fsl_sh=fsl_sh)

    print("TBSS registration...")
    tbss_2_reg(
        output_dir=tbss_dir,
        use_fmrib58_fa_1mm=use_fmrib58_fa_1mm,
        target_img=target_img,
        find_best_target=find_best_target,
        fsl_sh=fsl_sh)

    if find_best_target or target_img is not None:
        mean_study = True
    else:
        mean_study = False

    print("TBSS post-registration...")
    tbss_3_postreg(
        output_dir=tbss_dir,
        mean_study=mean_study,
        use_fmrib58_fa=use_fmrib58_fa_1mm,
        fsl_sh=fsl_sh)

    print("TBSS pre-stats...")
    tbss_4_prestats(
        output_dir=tbss_dir,
        threshold=skel_threshold,
        fsl_sh=fsl_sh)


def tbss_1_preproc(output_dir, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_1_preproc command to erode the FA images slightly and
        zero the end slices (to remove likely outliers from the diffusion
        tensor fitting).
    For more information, refer to :
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    output_dir: str (required)
        path to output directory where orig and FA directories will be created
        and where FA files are stored.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    fa_dir: str
        path to the subjects corrected FA files.
    orig_dir: str
        path to the copied subjects original FA files.
    """
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)
    os.chdir(output_dir)
    cmd = ["tbss_1_preproc", "*.nii.gz"]
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()
    fa_dir = os.path.join(output_dir, "FA")
    orig_dir = os.path.join(output_dir, "origdata")
    if not os.path.isdir(fa_dir):
        raise ValueError(
            "tbss_1_preproc did not create FA dir : {0}...".format(fa_dir))
    if not os.path.isdir(orig_dir):
        raise ValueError(
            "tbss_1_preproc did not create orig dir : {0}...".format(orig_dir))
    return fa_dir, orig_dir


def tbss_2_reg(output_dir, use_fmrib58_fa_1mm=False, target_img=None,
               find_best_target=True, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_2_reg command to non-linearly register the FA images
        to a 1x1x1mm standard space.
    For more information, refer to :
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    output_dir: str (required)
        path to output directory.
    use_fmrib58_fa_1mm: bool (optional, default True)
        use FMRIB58_FA_1mm as target for nonlinear registrations (recommended).
    target_img: str (optional, default None)
        path to a target image to use for nonlinear registration.
    find_best_target: bool (default False)
        option to find best target from all FA images.
    fsl_sh: str
        path to fsl setup sh file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["tbss_2_reg"]
    if use_fmrib58_fa_1mm:
        cmd.append("-T")
    elif target_img is not None:
        cmd.append("-t")
        cmd.append(target_img)
    elif find_best_target:
        cmd.append("-n")
    else:
        raise ValueError("Please enter valid parameters for function"
                         " tbss_2_reg.")
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()


def tbss_3_postreg(output_dir, mean_study=True, use_fmrib58_fa=False,
                   fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_3_postreg command to apply the nonlinear transforms
        found in the previous stage to all subjects to bring them into
        standard space. Merge results into a single 4D image.
        Compute a mean FA image and the corresponding skeletonisation.
    For more information, refer to :
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    output_dir: str (required)
        path to output directory.
    mean_study: bool (optional, default True)
        derive mean_FA and mean_FA_skeleton from mean of all subjects in study
        (recommended).
    use_fmrib58_fa: bool (optional, default False)
        use FMRIB58_FA and its skeleton instead of study-derived mean and
        skeleton.
    fsl_sh: str
        path to fsl setup sh file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["tbss_3_postreg"]
    if mean_study:
        cmd.append("-S")
    elif use_fmrib58_fa:
        cmd.append("-T")
    else:
        raise ValueError("Please enter valid parameters for function"
                         " tbss_3_postreg.")
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()


def tbss_4_prestats(output_dir, threshold=0.2, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_4_prestats command to thresholds the mean FA skeleton
        image at the chosen threshold, create a distance map, and project the
        FA data onto the mean FA skeleton.
        To be used before any voxelwise cross-subject stats.

    For more information, refer to :
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    output_dir: str (required)
        path to output directory.
    threshold: float (required, default 0.2)
    fsl_sh: str
        path to fsl setup sh file.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = ["tbss_4_prestats", str(threshold)]
    fslprocess = FSLWrapper(cmd, shfile=fsl_sh)
    fslprocess()
