#! /usr/bin/env python
##########################################################################
# NSAp - Copyright (C) CEA, 2016
# Distributed under the terms of the CeCILL-B license, as published by
# the CEA-CNRS-INRIA. Refer to the LICENSE file or to
# http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html
# for details.
##########################################################################

# System modules
from __future__ import print_function
import os
import shutil
import glob
import json
import argparse
from datetime import datetime
from pprint import pprint
import textwrap
import numpy


# Bredala module
try:
    import bredala
    bredala.USE_PROFILER = False
    bredala.register("pyconnectome.tractography.probabilist",
                     names=["probtrackx2"])
except:
    pass

# Package import
from pyconnectome import __version__ as version
from pyconnectome import DEFAULT_FSL_PATH
from pyconnectome.wrapper import FSLWrapper
from pyconnectome.tractography.probabilist import probtrackx2


# Parameters to keep trace
__hopla__ = ["runtime", "inputs", "outputs"]


# Command parameters
doc = """
FSL Probtrackx2
~~~~~~~~~~~~~~~

Perform FSL probabilistic tractography in a single subject using a seeding
point in voxel coordinates.

**Command**

python $HOME/git/pyfsl/pyconnectome/scripts/pyconnectome_probtrackx2 \
    -c /etc/fsl/5.0/fsl.sh \
    -s 1002008 \
    -o /volatile/nsap/hcp \
    -b /neurospin/tmp/slefranc/HCP/102008/diffusion.bedpostX \
    -p 71 120 59 \
    -i 3 \
    -l 0.75 \
    -v 2
"""


def is_file(filearg):
    """ Type for argparse - checks that file exists but does not open.
    """
    if not os.path.isfile(filearg):
        raise argparse.ArgumentError(
            "The file '{0}' does not exist!".format(filearg))
    return filearg


def is_directory(dirarg):
    """ Type for argparse - checks that directory exists.
    """
    if not os.path.isdir(dirarg):
        raise argparse.ArgumentError(
            "The directory '{0}' does not exist!".format(dirarg))
    return dirarg


parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=textwrap.dedent(doc))
required = parser.add_argument_group("required arguments")
parser.add_argument(
    "-c", "--config", dest="fslconfig", metavar="<path>",
    help="the FSL configuration file.", type=is_file)
required.add_argument(
    "-s", "--subjectid", required=True, metavar="<id>",
    help="Subject identifier.")
required.add_argument(
    "-o", "--outdir", required=True, metavar="<path>",
    help="directory where to output.", type=is_directory)
required.add_argument(
    "-b", "--beddir", dest="bedpostxdir", required=True, metavar="<path>",
    help="the FSL bedpostx directory.", type=is_directory)
required.add_argument(
    "-p", "--point", dest="point", required=True, metavar="<seed>", nargs=3,
    help="A seeding point in index coordinates.", type=int)
required.add_argument(
    "-i", "--index", dest="index", required=True, metavar="<id>",
    help="An index associated to the current seeding point.", type=int)
parser.add_argument(
    "-a", "--nsamples", dest="nsamples", metavar="<int>", default=5000,
    help="the number of samples in probtrackx.", type=int)
parser.add_argument(
    "-t", "--nsteps", dest="nsteps", metavar="<int>", default=2000,
    help="the number of steps per sample in probtrackx.", type=int)
parser.add_argument(
    "-l", "--steplength", dest="steplength", metavar="<float>", default=0.5,
    help="the propagation step in probtrackx.", type=float)
parser.add_argument(
    "-m", "--sampvox", dest="sampvox", metavar="<float>", default=0.0,
    help="random sampling sphere in probtrackx (in mm).", type=float)
parser.add_argument(
    "-e", "--erase", dest="erase", action="store_true",
    help="if activated, clean the subject folder.")
parser.add_argument(
    "-v", "--verbose", dest="verbose", type=int, choices=[0, 1, 2], default=0,
    help="increase the verbosity level: 0 silent, [1, 2] verbose.")
args = parser.parse_args()
inputs = vars(args)
verbose = inputs.pop("verbose")
fsl_config =  inputs.pop("fslconfig") or DEFAULT_FSL_PATH


"""
First check if the subject FSL directory exists on the file system, and
clean it if requested. Check also the bedpostx directory.
"""
tool = "pyconnectome_probtrackx2"
timestamp = datetime.now().isoformat()
tool_version = version
fsl_version = FSLWrapper([], shfile=fsl_config).version
params = locals()
runtime = dict([(name, params[name])
               for name in ("fsl_config", "tool", "tool_version",
                            "fsl_version", "timestamp")])
outputs = None
if verbose > 0:
    print("[info] Starting FSL probtrackx2 ...")
    print("[info] Runtime:")
    pprint(runtime)
    print("[info] Inputs:")
    pprint(inputs)
subjectdir = os.path.join(inputs["outdir"], inputs["subjectid"])
if inputs["erase"] and os.path.isdir(subjectdir):
    shutil.rmtree(subjectdir)
if not os.path.isdir(subjectdir):
    os.mkdir(subjectdir)
merged_prefix = os.path.join(inputs["bedpostxdir"], "merged")
merged_files = glob.glob(merged_prefix + "*")
if len(merged_files) == 0:
    raise ValueError("'{0}' is not a valid FSL bedpostx folder.".format(
        inputs["bedpostxdir"]))
nodifmask_file = os.path.join(inputs["bedpostxdir"], "nodif_brain_mask.nii.gz")
if not os.path.isfile(nodifmask_file):
    raise ValueError("'{0}' is not a valid FSL bedpostx folder.".format(
        inputs["bedpostxdir"]))


"""
Write seeding index coordinates to file.
"""
wdir = os.path.join(subjectdir, "{0}".format(inputs["index"]))
if not os.path.isdir(wdir):
    os.mkdir(wdir)
seed_file = os.path.join(wdir, "fdt_coordinates.txt")
numpy.savetxt(seed_file, inputs["point"])


"""
Generates the diffusion probability map from the input seeding point.
"""
proba_files, _ = probtrackx2(
    samples=merged_prefix,
    mask=nodifmask_file,
    seed=seed_file,
    nsamples=inputs["nsamples"],
    nsteps=inputs["nsteps"],
    steplength=inputs["steplength"],
    sampvox=inputs["sampvox"],
    simple=True,
    loopcheck=True,
    dir=wdir,
    out="fdt_paths",
    seedref=nodifmask_file,
    onewaycondition=True,
    opd=True,
    forcedir=True,
    savepaths=True,
    shfile=fsl_config)


"""
Update the outputs and save them and the inputs in a 'logs' directory.
"""
logdir = os.path.join(wdir, "logs")
if not os.path.isdir(logdir):
    os.mkdir(logdir)
shutil.move(os.path.join(wdir, "probtrackx.log"),
            os.path.join(logdir, "probtrackx.log"))
params = locals()
outputs = dict([(name, params[name]) for name in ("proba_files", )])
for name, final_struct in [("inputs", inputs), ("outputs", outputs),
                           ("runtime", runtime)]:
    log_file = os.path.join(logdir, "{0}.json".format(name))
    with open(log_file, "wt") as open_file:
        json.dump(final_struct, open_file, sort_keys=True, check_circular=True,
                  indent=4)
if verbose > 1:
    print("[info] Outputs:")
    pprint(outputs)

